%This file discusses our proposed approach and validation methods.
%This file should be icluded in main document with \input{file}
\section{Proposed Approach and Validation}
We have decided to approach the design of the controller by breaking it down into two phases, each phase will consist of four months. The first phase will deal purely with simulation and proof of concept testing of the hardware to gain a better understanding of what we were working with. The second phase will be to apply what we've learned during the first phase to develop the flight controller software.

\subsection{First Phase}
Before we can begin developing the flight controller we must first decide on which type of contol will be optimal for our application. The types of control we will consider are Proportional Integral and Proportional Integral Derivative. Each type of control will be applied to a simple simulation that outputs an the reaction torque of a 1kg body to a step input, which ever control supplies the most steady value of non-zero average torque will be the control type we will move forward with. Upon deciding which control type we will be using more advanced simulations will be run.

The more advanced simulation will consist of a 3D representation of the drone that is connected to various subsystems. The response of the system to a step input will be studied and the system will be tuned to obtain a reasonable response. The response we're going to achieve will simulate that the drone is hovering in a location, this response should be resemblant to that of a sinusoidal function. Upon completion of the simulations Proof of Concept (POC) testing will be performed. 

The POC testing will consist of the following items: determining methods to control the motor speed, characteristics and limitations of the hardware and software and which communication protocol is optimal. 

The main method we will be implementing to test control of the motor speed is the apply different pulse lengths to the motor. This will be achieved by using Pulse Width Modulation (PWM) applied at different duty cycles. A script will be written that applies a voltage across a potentiometer that can then be varried to apply different duty cycles. The duty cycle will be displayed on a serial terminal to easily determine the current draw vs duty cycle characteristic of the motor. 

Upon validating that the motor speed can be controlled using PWM characterization of the Electronic Speed Controllers (ESC) and BLDC motors will be performed. The ESC tests will attempt to prove that the ESC's are capable of controlling the motor speed using a variable input supplied by a potentiometer using the PWM script. To test the lift capability of a single BLDC motor a weight will be attached to a support system with the motor and blade attached to it. The weight appartatus will be placed on a zeroized scale and then power will be applied to the motor, as the propeller speed increases the reduction in weight read from the scale will be considered the lift capability. The test will be performed at various pulse width's to form a current draw versus pulse width characterization of the motor with a specified weight attached to it. 

To determine which communication protocol (Wi-Fi or Bluetooth) will be optimal for our application basic range tests will be performed. To test Wi-Fi range, a Wi-Fi communicating device tethered to a Wi-Fi output from a cell phone will given to a user, the user will then walk a certain distance until communication is lost. To test the Bluetooth range a similar test will be conducted, communication will be established between a Raspberry Pi 3 and Playstation 4 controller a user will then walk a certain distance with the controller until communication is lost. Which ever tests supplies the longest distance before communication is lost will be deemed optimal for our application.

To validate that communcation can be established between the Raspberry Pi 3 and Arduino the I2C bus on the Raspberry Pi will be enabled and an open source script will be run. This simple tests will prove that communication between the microprocessor and microcontroller can be achieved.

\subsection{Second Phase}
The second phase of the project will consist of applying what we've learned throughout the first phase to design the flight controller and the GUI. The two main goals of the second phase will be that the flight controller is able to receive control inputs from the GUI and responses appropriately and that the GUI functions as outlined in the Objectives and Deliverables section.

The development of the flight controller and GUI will be done in parallel. The leads for each of these tasks can be found in the Distribution of Tasks section. The reason we will be approaching it this way is the ensure that no one is reliant on another person to get their work done but this will also require close contact between the team leads to ensure that the flight controller and GUI are compatible. Weekly meetings and daily contact will ensure the compatibility of the two.

To validate that the GUI is functioning as intended a few basic tests will be performed: The controller is able to receive control inputs from the GUI over Wi-Fi, appropriate Global Position Sensor (GPS) coordinates are displayed as the drone travels, new software builds are able to be loaded onto the hardware from the GUI and once a new software build is loaded the name of the build is located on the GUI. These tests will validate the the GUI is functioning as intended. 

The flight controller tests will consist of applying various types of control inputs and disturbances and observing how the controller responds. This will validate that the controller operates within the given constraints. 
